---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```{python}
from CitizenUAV.models import InatClassifier
from CitizenUAV.data import GTiffDataset, InatDataModule
import numpy as np
import os
from torchmetrics.functional import confusion_matrix, precision_recall
from torchmetrics import Accuracy, F1Score
import torch
from tqdm import tqdm
from torch.utils.data import DataLoader
from torchvision.datasets import ImageFolder
from collections import Counter
from matplotlib import pyplot as plt
import pandas as pd
import seaborn as sns
```

```{python}
data_dir = '/home/ndettmer/data/UOS_Data/'
dataset_path = os.path.join(data_dir, '220518_maize_rgb.tif')
shape_dir = os.path.join(data_dir, '1805_maize')
ds = GTiffDataset(dataset_path, shape_dir=shape_dir, stride=4, normalize=True)
model_path = '/home/ndettmer/experiments/ma/classification/maize_ternary/lightning_logs/version_0/checkpoints/epoch=49-step=43200.ckpt'
model = InatClassifier.load_from_checkpoint(model_path)
_ = model.eval()
if torch.cuda.is_available():
    model.cuda()
```

```{python}
ds.classes
```

```{python}
inat_classes = ImageFolder('/home/ndettmer/data/inat_subsets/maize_ternary').classes
inat_class_to_idx = {c: i for i, c in enumerate(inat_classes)}

gt_classes_to_inat_classes = {
    'soil': 'soil',
    'weeds': 'weed',
    'maize': 'zea mays'
}
inat_classes_to_gt_classes = {v: k for k, v in gt_classes_to_inat_classes.items()}

gt_cls_idx_to_inat_cls_idx = {}

for gt_cls in ds.classes:
    gt_cls_idx = ds.class_to_idx[gt_cls]
    inat_cls = gt_classes_to_inat_classes[gt_cls]
    inat_cls_idx = inat_class_to_idx[inat_cls]
    gt_cls_idx_to_inat_cls_idx[gt_cls_idx] = inat_cls_idx

inat_cls_idx_to_gt_cls_idx = {v: k for k, v in gt_cls_idx_to_inat_cls_idx.items()}
```

```{python}
inat_classes
```

```{python}
ds.rds.height, ds.rds.width
```

```{python}
rnd_probs = np.random.rand(3, ds.rds.height, ds.rds.width)
```

```{python}
np.save('/home/ndettmer/experiments/ma/classification/maize_ternary/predictions/220518_maize_rgb/23-02-02_15-24_probability_map.npy', rnd_probs)
```

<!-- #region tags=[] jp-MarkdownHeadingCollapsed=true jp-MarkdownHeadingCollapsed=true tags=[] -->
## By Window
<!-- #endregion -->

```{python}
# determine class distribution
dl = DataLoader(ds, batch_size=128, num_workers=os.cpu_count())

batch_targets = []
for batch in tqdm(iter(dl)):
    _, t = batch
    batch_targets.append(t)

batch_targets = torch.concat(batch_targets, dim=0)
n_samples = dict(Counter(list(batch_targets.numpy())))
n_samples = {ds.classes[k]: v for k, v in n_samples.items()}
n_samples
```

```{python}
# TODO fit for large sample sizes
sample_size = min(n_samples.values()) * 3
samples_per_class = sample_size // 3
sample_idx = np.random.choice(range(len(ds)), size=len(ds))

targets = []
imgs = []

sample_counter = {c: 0 for c in ds.classes}

for idx in tqdm(sample_idx):
    img, t = ds[idx]
    
    if sample_counter[ds.classes[t]] < samples_per_class:
        imgs.append(img)
        targets.append(t)
    
    sample_counter[ds.classes[t]] += 1
    
    if all([n >= samples_per_class for n in sample_counter.values()]):
        break
```

```{python}
imgs = torch.stack(imgs, dim=0)
if torch.cuda.is_available():
    imgs = imgs.cuda()
    
with torch.no_grad():
    y_hat = model(imgs)
preds = torch.argmax(y_hat, dim=1)
confs = torch.max(y_hat, dim=1)
```

```{python}
inat_targets = []
for t in targets:
    inat_targets.append(gt_cls_idx_to_inat_cls_idx[t])
```

```{python}
cls_dist = dict(Counter(inat_targets))
cls_dist = {inat_classes[k]: v for k, v in cls_dist.items()}
```

```{python}
cls_dist
```

```{python}
inat_targets = torch.IntTensor(inat_targets)
preds = preds.cpu().int()
```

```{python}
cm = confusion_matrix(preds, inat_targets, num_classes=3)
df_cm = pd.DataFrame(cm.numpy(), index=range(3), columns=range(3))
plt.figure()
sns.heatmap(df_cm, annot=True, cmap='Spectral', fmt='g').get_figure()
plt.title(str(dict(enumerate(inat_classes))))
plt.savefig('/home/ndettmer/experiments/ma/classification/maize_ternary/lightning_logs/version_0/220518_maize_rgb_window_confmat.png')
```

```{python}
precision, recall = precision_recall(preds, torch.IntTensor(inat_targets), num_classes=3)
print(f"Precision: {precision}")
print(f"Recall: {recall}")
```

```{python}
f1 = F1Score(num_classes=3)
float(f1(torch.IntTensor(preds), torch.IntTensor(inat_targets)))
```

```{python}
acc = Accuracy(num_classes=3)
float(acc(torch.IntTensor(preds), torch.IntTensor(inat_targets)))
```

<!-- #region tags=[] -->
## By Pixel
<!-- #endregion -->

```{python}
pred_dir = '/home/ndettmer/experiments/ma/classification/maize_ternary/predictions/220518_maize_rgb'
pred_file = os.path.join(pred_dir, '23-01-31_12-04_probability_map.npy')
```

```{python}
# load predictions and confidences
prob_map = np.load(pred_file)
pred_map = np.argmax(prob_map, axis=0)
conf_map = np.max(prob_map, axis=0)
del prob_map
```

```{python}
# get pixel positions of labeled area
labeled_idx = np.argwhere(ds.get_labeled_area())
```

```{python}
# create target map with inat targets 
target_map = np.full((model.n_classes, ds.rds.height, ds.rds.width), 0, dtype=bool)
for inat_class in set(inat_classes) ^ {'soil'}:
    # get inat class index
    inat_cls_idx = inat_class_to_idx[inat_class]
    # get corresponding raster class index
    gt_cls_idx = inat_cls_idx_to_gt_cls_idx[inat_cls_idx]
    
    # get class target coverage from raster dataset
    cls_mask = ds.get_cls_mask(gt_cls_idx)
    cover_idx = np.argwhere(cls_mask)
    
    # map coverage to target map with inat class indices
    target_map[inat_cls_idx, cover_idx[:, 0], cover_idx[:, 1]] = True

# treat soil separately by just filling the empty space with the soil label
target_map[inat_class_to_idx['soil']] = ~ (target_map[inat_class_to_idx['weed']] | target_map[inat_class_to_idx['zea mays']])

# condence map to 1 layer with class indices
target_map = np.argmax(target_map, axis=0)
```

```{python}
# get target list and prediciton list out of the labeled area
targets = target_map[labeled_idx[:, 0], labeled_idx[:, 1]]
preds = pred_map[labeled_idx[:, 0], labeled_idx[:, 1]]
```

```{python}
# balance classes by targets
label_dist = dict(Counter(targets))
label_dist = {inat_classes[k]: v for k, v in label_dist.items()}
n = min(label_dist.values())

# cut over-represented classes 
soil_labeled_idx = np.argwhere(targets == inat_class_to_idx['soil'])[:n]
weed_labeled_idx = np.argwhere(targets == inat_class_to_idx['weed'])[:n]
maize_labeled_idx = np.argwhere(targets == inat_class_to_idx['zea mays'])[:n]

# combine the indices again
eval_idx = np.concatenate([soil_labeled_idx, weed_labeled_idx, maize_labeled_idx], axis=0)

# select samples from targets and predictions
targets = targets[eval_idx]
preds = preds[eval_idx]
```

```{python}
target_dist = dict(Counter(targets.reshape(-1)))
target_dist = {inat_classes[k]: v for k, v in target_dist.items()}
target_dist
```

```{python}
pred_dist = dict(Counter(preds.reshape(-1)))
pred_dist = {inat_classes[k]: v for k, v in pred_dist.items()}
pred_dist
```

```{python}
# convert to tensors
targets = torch.IntTensor(targets)
preds = torch.IntTensor(preds)
```

```{python}
# create confusion matrix
cm = confusion_matrix(preds, targets, num_classes=3)
df_cm = pd.DataFrame(cm.numpy(), index=range(3), columns=range(3))
plt.figure()# convert to tensors
targets = torch.IntTensor(targets)
preds = torch.IntTensor(preds)
sns.heatmap(df_cm, annot=True, cmap='Spectral', fmt='g').get_figure()
plt.title(str(dict(enumerate(inat_classes))))
plt.savefig('/home/ndettmer/experiments/ma/classification/maize_ternary/lightning_logs/version_0/220518_maize_rgb_pixel_confmat.png')
```

```{python}
precision, recall = precision_recall(torch.IntTensor(preds), torch.IntTensor(targets), num_classes=3)
print(f"Precision: {precision}")
print(f"Recall: {recall}")
```

```{python}
f1 = F1Score(num_classes=3)
float(f1(torch.IntTensor(preds), torch.IntTensor(targets)))
```

```{python}
acc = Accuracy(num_classes=3)
float(acc(torch.IntTensor(preds), torch.IntTensor(targets)))
```
